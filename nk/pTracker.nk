#! C:/Program Files/Nuke7.0v4/Nuke7.0.exe -nx
#http://bjorkvisuals.com/tools/the-foundrys-nuke/gizmos
version 8.0 v1
Group {
name sb_PositionTracker
inputs 3
help "sb_positionTracker\nVersion 2.0\nSimon Bjork\nbjork.simon@gmail.com\nwww.bjorvisuals.com\n"
tile_color 0xff00ffff
note_font Verdana
mapsize {0.15 0.15}
addUserKnob {20 controls}
addUserKnob {12 bl l INVISIBLE +INVISIBLE}
addUserKnob {12 br l INVISIBLE +INVISIBLE}
addUserKnob {12 ur l INVISIBLE +INVISIBLE}
addUserKnob {12 ul l INVISIBLE +INVISIBLE}
addUserKnob {26 divider1 l "" +STARTLINE}
addUserKnob {41 in l "position channel" T position_to_rgb.in}
addUserKnob {26 divider2 l "" +STARTLINE}
addUserKnob {26 info l "" +STARTLINE T "Hold down Ctrl+Alt to sample the Position pass."}
addUserKnob {41 bl_sampler l "bottom left" T sampler.bl_sampler}
addUserKnob {41 br_sampler l "bottom right" T sampler.br_sampler}
addUserKnob {41 ur_sampler l "upper right" T sampler.ur_sampler}
addUserKnob {41 ul_sampler l "upper left" T sampler.ul_sampler}
addUserKnob {22 reset_val l reset T "n = nuke.thisNode()\n\nfor i in \[\"bl\", \"br\",\"ur\", \"ul\"]:\n\tn\[\"\{0\}_sampler\".format(i)].setValue(\[0,0,0])\n\tn\[i].clearAnimated()\n\tn\[i].setValue(\[0,0])\n\nn\[\"ff\"].setValue(1)\nn\[\"lf\"].setValue(1)\n\nn\[\"keyframes_exists\"].setValue(\"No keyframes generated.\")" +STARTLINE}
addUserKnob {26 divider3 l "" +STARTLINE}
addUserKnob {22 gen_keys l "generate keyframes" T "################\n\n\"\"\"\n\tsbPositionTracker_generateKeyframes():\n\tSimon Bjork\n\tMarch 2014\n\n\tGenerate 2d keyframes from color sample.\n\n\tUpdated some of the nukescripts.snap3d functions to accept a frame and format argument.\n\tIvan Busquets posted the code to give the frame argument to CameraProjectionMatrix()\n\thttp://forums.thefoundry.co.uk/phpBB2/viewtopic.php?p=26502&sid=90d2f80543be7b2bf2decbeb556eaea7\n\n\"\"\"\n\n################\n\nimport nuke\nimport _nukemath\nimport nukescripts\nimport math\n\n################\n\ndef shuffleWorldMatrix(node, frame):\n\t\n\tmatrixList = node\[\"world_matrix\"].valueAt(frame)\n\t\n\t# Reorder list and put it into a matrix.\n\torder = \[0,4,8,12,1,5,9,13,2,6,10,14,3,7,11,15]\n\t\n\tmatrix = _nukemath.Matrix4()\n\t\n\tfor i in range(16):\n\t\tmatrix\[i] = matrixList\[ order\[i] ]\n\n\treturn matrix\n\n# Updated version.\ndef fixedCameraProjectionMatrix(cameraNode, format, frame):\n\n\t'''Calculate the projection matrix for the camera, based on it's knob values.'''\n\n\tshuffledWorldMatrix = shuffleWorldMatrix(cameraNode, frame)\n\tcamTransform = shuffledWorldMatrix.inverse()\n\n\t# Matrix to take the camera projection knobs into account \n\troll = float(cameraNode\['winroll'].getValueAt(frame)) \n\tscale_x, scale_y = \[float(v) for v in cameraNode\['win_scale'].getValueAt(frame)] \n\ttranslate_x, translate_y = \[float(v) for v in cameraNode\['win_translate'].getValueAt(frame)] \n\tm = _nukemath.Matrix4() \n\tm.makeIdentity() \n\tm.rotateZ(math.radians(roll)) \n\tm.scale(1.0 / scale_x, 1.0 / scale_y, 1.0) \n\tm.translate(-translate_x, -translate_y, 0.0)\n\n\t# Projection matrix based on the focal length, aperture and clipping planes of the camera \n\tfocal_length = float(cameraNode\['focal'].getValueAt(frame)) \n\th_aperture = float(cameraNode\['haperture'].getValueAt(frame)) \n\tnear = float(cameraNode\['near'].getValueAt(frame)) \n\tfar = float(cameraNode\['far'].getValueAt(frame)) \n\tprojection_mode = int(cameraNode\['projection_mode'].getValueAt(frame)) \n\tp = _nukemath.Matrix4() \n\tp.projection(focal_length / h_aperture, near, far, projection_mode == 0)\n\n\t# Matrix to translate the projected points into normalised pixel coords. \n\timageAspect = float(format.height()) / float(format.width())\n\tt = _nukemath.Matrix4()\n\tt.makeIdentity() \n\tt.translate( 1.0, 1.0 - (1.0 - imageAspect / float(format.pixelAspect())), 0.0 )\n\n\t# Matrix to scale normalised pixel coords into actual pixel coords. \n\tx_scale = float(format.width()) / 2.0 \n\ty_scale = x_scale * format.pixelAspect() \n\ts = _nukemath.Matrix4() \n\ts.makeIdentity()\n\ts.scale(x_scale, y_scale, 1.0)\n\n\t# The projection matrix transforms points into camera coords, modifies based \n\t# on the camera knob values, projects points into clip coords, translates the \n\t# clip coords so that they lie in the range 0,0 - 2,2 instead of -1,-1 - 1,1, \n\t# then scales the clip coords to proper pixel coords. \n\treturn s * t * p * m * camTransform\n\n# Updated version.\ndef fixedProjectPoints(camera=None, points=None, format=None, frame=None):\n\n\tcamNode = None\n\tif isinstance(camera, nuke.Node):\n\t\tcamNode = camera\n\telif isinstance(camera, str):\n\t\tcamNode = nuke.toNode(camera)\n\telse:\n\t\traise ValueError, \"Argument camera must be a node or the name of a node.\"\n\n\tcamMatrix = fixedCameraProjectionMatrix(camNode, format, frame)\n\n\tif camMatrix == None:\n\t\traise RuntimeError, \"snap3d.cameraProjectionMatrix() returned None for camera.\"\n\n\tif not ( isinstance(points, list) or isinstance(points, tuple) ):\n\t\traise ValueError, \"Argument points must be a list or tuple.\"\n\n\tfor point in points:\n\t\t# Would be nice to not do this for every item but since lists/tuples can\n\t\t# containg anything...\n\t\tif isinstance(point, nuke.math.Vector3):\n\t\t\tpt = point\n\t\telif isinstance(point, list) or isinstance(point, tuple):\n\t\t\tpt = nuke.math.Vector3(point\[0], point\[1], point\[2])\n\t\telse:\n\t\t\traise ValueError, \"All items in points must be nuke.math.Vector3 or list/tuple of 3 floats.\"\n\n\t\ttPos = camMatrix * nuke.math.Vector4(pt.x, pt.y, pt.z, 1.0)\n\t\tyield nuke.math.Vector2(tPos.x / tPos.w, tPos.y / tPos.w)\n\n# Updated version.\ndef fixedProjectPoint(camera=None, point=None, format=None, frame=None):\n\t\n\treturn fixedProjectPoints( camera, (point,), format, frame ).next()\n\ndef getCameraInput(node, input):\n\n\t# Get the connected camera, igoring dots and everything else between.    \n    found = False \n    \n    while not found:\n\n        # Get input.        \n        currInput = node.input(input)\n        \n        # If no input is found, return False.\n        if currInput == \"\" or currInput == None:\n            return False\n\n        if not currInput.Class() in \[\"Camera\", \"Camera2\"]:\n            # If not found, keep looking.\n            return getCameraInput(currInput, 0) \n        else: \n            found = True \n            return currInput\n\ndef sbPositionTracker_generateKeyframes():\n\n\tn = nuke.thisNode()\n\n\tp = nuke.Panel (\"Set frame-range\")\n\tp.addSingleLineInput('Start', int(nuke.root()\[\"first_frame\"].value()))\n\tp.addSingleLineInput('End', int(nuke.root()\[\"last_frame\"].value()))\n\tresult=p.show()\n\n\tif not result:\n\t\tprint \"Cancelled by user.\"\n\t\treturn\n\n\tcam = getCameraInput(n, 2)\n\n\tif not cam:\n\t\tnuke.message(\"Connect a camera.\")\n\t\treturn\n\n\tbl_sample = n\[\"bl_sampler\"].value()\n\tbr_sample = n\[\"br_sampler\"].value()\n\tur_sample = n\[\"ur_sampler\"].value()\n\tul_sample = n\[\"ul_sampler\"].value()\n\n\tformat = n.format()\n\n\tfor i in \[\"bl\", \"br\", \"ur\", \"ul\"]:\n\t\tn\[i].clearAnimated()\n\t\tn\[i].setAnimated()\n\n\t# First and last frame.\n\tff = int(p.value('Start'))\n\tlf = int(p.value('End'))\n\n\t# Setup progress bar.\n\ttask = nuke.ProgressTask('Generating keyframes...')\n\tprogressCalc = 100.0/float(lf-ff)\n\tcounter = 0\n\n\tfor i in range(ff, lf+1):\n\n\t\tif task.isCancelled():\n\t\t\tprint \"Cancelled by user.\"\n\t\t\t# Set knob values.\n\t\t\tn\[\"ff\"].setValue(ff)\n\t\t\tn\[\"lf\"].setValue(i-1)\n\t\t\tn\[\"keyframes_exists\"].setValue(\"Keyframes generated between \{0\}-\{1\}.\".format(ff, i-1))\n\t\t\treturn\n\n\t\t# Convert 3d to 2d.\n\t\tbl2d = fixedProjectPoint(cam, bl_sample, format, i )\n\t\tn\[\"bl\"].setValueAt(bl2d\[0], i, 0)\n\t\tn\[\"bl\"].setValueAt(bl2d\[1], i, 1)\n\n\t\tbr2d = fixedProjectPoint(cam, br_sample, format, i )\n\t\tn\[\"br\"].setValueAt(br2d\[0], i, 0)\n\t\tn\[\"br\"].setValueAt(br2d\[1], i, 1)\n\n\t\tur2d = fixedProjectPoint(cam, ur_sample, format, i )\n\t\tn\[\"ur\"].setValueAt(ur2d\[0], i, 0)\n\t\tn\[\"ur\"].setValueAt(ur2d\[1], i, 1)\n\n\t\tul2d = fixedProjectPoint(cam, ul_sample, format, i )\n\t\tn\[\"ul\"].setValueAt(ul2d\[0], i, 0)\n\t\tn\[\"ul\"].setValueAt(ul2d\[1], i, 1)\n\n\t\t# Update progress bar.\n\t\ttask.setProgress(int(counter*progressCalc))\n\t\ttask.setMessage(\"Frame \{0\}\".format(i))\n\t\tcounter +=1\n\n\t# Delete progress bar.\n\tdel task\n\n\t# Set knob values.\n\tn\[\"ff\"].setValue(ff)\n\tn\[\"lf\"].setValue(lf)\n\tn\[\"keyframes_exists\"].setValue(\"Keyframes generated between \{0\}-\{1\}.\".format(ff, lf))\n\nsbPositionTracker_generateKeyframes()" +STARTLINE}
addUserKnob {3 ff l INVISIBLE +INVISIBLE}
ff 1
addUserKnob {3 lf l INVISIBLE +INVISIBLE}
lf 1
addUserKnob {26 keyframes_exists l "" +STARTLINE T "No keyframes generated."}
addUserKnob {26 divider4 l "" +STARTLINE}
addUserKnob {4 output_node l output M {"CornerPin Match-move (Plane)" "CornerPin Stabilize (Plane)" Tracker RotoPaint GridWarp SplineWarp ""}}
addUserKnob {3 ref_frame l "reference frame"}
ref_frame 1
addUserKnob {22 set_frame l "set to this frame" -STARTLINE T "n = nuke.thisNode()\nf = nuke.frame()\nn\[\"ref_frame\"].setValue(f)"}
addUserKnob {26 divider5 l "" +STARTLINE}
addUserKnob {22 create_node l "create node" T "####################\n\n\"\"\"\n    sb_positionTracker\n    Simon Bjork\n    Version 2.0\n    March 2014\n    bjork.simon@gmail.com\n    www.bjorkvisuals.com\n\n    To be used in sb_positionTracker gizmo.\n\n\"\"\"\n\n####################\n\nfrom __future__ import with_statement\nimport nuke\nimport nuke.rotopaint as rp\nimport threading\n\n####################\n\ndef pointsToMatrix(pointList, ref, ff, lf):\n\n    # The pointList argument is a list with knobs that holds XY data. The list is in the following order: bottom left, bottom right, upper right, upper left.\n    # Returns a list containing matrix values.\n\n    animatedMatrix = \[]\n\n    projectionMatrixTo = nuke.math.Matrix4()\n    projectionMatrixFrom = nuke.math.Matrix4()\n\n    # Get the from values.\n    fromValues = \[]\n    for i in range(4):\n        for j in range(2):\n            fromValues.append(pointList\[i].valueAt(ref)\[j])\n\n    # Calculate the matrix.\n    for i in range(ff, lf+1):\n        toValues = \[]\n        for j in range(4):\n            for k in range(2):\n                to = pointList\[j].valueAt(i)\[k]\n                toValues.append(to)\n\n        projectionMatrixTo.mapUnitSquareToQuad(toValues\[0], toValues\[1], toValues\[2], toValues\[3], toValues\[4], toValues\[5], toValues\[6], toValues\[7])\n        projectionMatrixFrom.mapUnitSquareToQuad(fromValues\[0], fromValues\[1], fromValues\[2], fromValues\[3], fromValues\[4], fromValues\[5], fromValues\[6], fromValues\[7])\n\n        matrix = projectionMatrixTo*projectionMatrixFrom.inverse()    \n        matrix.transpose()\n\n        animatedMatrix.append(matrix)\n\n    return animatedMatrix\n\n\n# Main function.\ndef sb_positionTracker():\n\n    n = nuke.thisNode()\n    n\[\"selected\"].setValue(False)\n\n    # 2D data knobs.\n    bl = n\[\"bl\"]\n    br = n\[\"br\"]\n    ur = n\[\"ur\"]\n    ul = n\[\"ul\"]\n\n    # Useful variables.\n    ref = int(n\[\"ref_frame\"].value())\n    ff = int(n\[\"ff\"].value())\n    lf = int(n\[\"lf\"].value())\n    outputNode = n\[\"output_node\"].value()\n\n    # Create node (in root).\n    with nuke.root():\n\n        if outputNode == \"CornerPin Match-move (Plane)\" or outputNode == \"CornerPin Stabilize (Plane)\":\n\n            c = nuke.createNode(\"CornerPin2D\")\n\n            # Add reference frame.\n            tab = nuke.Tab_Knob(\"ref\", \"Reference frame\")\n            c.addKnob(tab)\n            rf = nuke.Int_Knob(\"rf\")\n            c.addKnob(rf)\n            rf.setLabel(\"Reference frame\")\n            c\[\"rf\"].setValue(ref)\n            stf = nuke.PyScript_Knob('stf')\n            stf.setLabel(\"Set to this frame\")\n            c.addKnob(stf)\n            stf.setCommand( 'nuke.thisNode()\[\"rf\"].setValue(nuke.frame())' )\n\n            if outputNode == \"CornerPin Match-move (Plane)\":\n                cornerPinMain = \"to\"\n                cornerPinRef = \"from\"\n                cornerPinTransform = \"match-move\"\n            else:\n                cornerPinMain = \"from\"\n                cornerPinRef = \"to\"\n                cornerPinTransform = \"stabilize\"\n\n            main1 = \"\{0\}1\".format(cornerPinMain)\n            main2 = \"\{0\}2\".format(cornerPinMain)\n            main3 = \"\{0\}3\".format(cornerPinMain)\n            main4 = \"\{0\}4\".format(cornerPinMain)\n\n            c\[main1].copyAnimations(bl.animations())\n            c\[main2].copyAnimations(br.animations())\n            c\[main3].copyAnimations(ur.animations())\n            c\[main4].copyAnimations(ul.animations())\n\n            c\[\"\{0\}1\".format(cornerPinRef)].setExpression(\"\{0\}(rf)\".format(main1))\n            c\[\"\{0\}2\".format(cornerPinRef)].setExpression(\"\{0\}(rf)\".format(main2))\n            c\[\"\{0\}3\".format(cornerPinRef)].setExpression(\"\{0\}(rf)\".format(main3))\n            c\[\"\{0\}4\".format(cornerPinRef)].setExpression(\"\{0\}(rf)\".format(main4))\n\n            c\[\"label\"].setValue(\"\{0\}\\nreference frame: \[value rf]\".format(cornerPinTransform))\n\n        elif outputNode == \"Tracker\":\n\n            # Need Nuke 7.0 to create a Tracker node.\n            if int(nuke.NUKE_VERSION_MAJOR) < 7:\n                nuke.message(\"You need to use Nuke 7.0 (or newer) to create a Tracker node.\")\n                return\n\n            c = nuke.createNode(\"Tracker4\")\n\n            # Add four tracks.\n            for i in range(4):\n                c\[\"add_track\"].execute()\n\n            tracker = c\[\"tracks\"]\n\n            # Number of columns.\n            numColumns = 31\n\n            # Set Translate, Rotate, Scale on all tracks.\n            for i in range(4):\n                for j in \[6,7,8]:\n                    tracker.setValue(1, numColumns*i+j)\n\n            # Setup progress bar.\n            task = nuke.ProgressTask('Adding keyframes...')\n            progressCalc = 100.0/float(lf-ff)\n            counter = 0\n\n            # Add tracking data.\n            for i in range(ff, lf+1):\n\n                index = 0\n                for j in \[bl, br, ur, ul]:\n                    tracker.setValueAt(j.valueAt(i)\[0], i, numColumns*index + 2)\n                    tracker.setValueAt(j.valueAt(i)\[1], i, numColumns*index + 3)\n                    index +=1\n\n                if task.isCancelled(): \n                    print \"Cancelled by user.\"\n                    break\n\n                # Update progress bar.\n                task.setProgress(int(counter*progressCalc))\n                task.setMessage(\"Frame \{0\}\".format(i))\n                counter +=1\n\n            del task\n\n            c\[\"reference_frame\"].setValue(ref)\n            c\[\"label\"].setValue(\"reference frame: \[value reference_frame]\")\n\n        else:\n\n            # Get the matrix list.\n            matrixList = pointsToMatrix(\[bl, br, ur, ul], ref, ff, lf)\n\n            if outputNode == \"RotoPaint\" or outputNode == \"SplineWarp\":\n\n                if outputNode == \"RotoPaint\":\n                    c = nuke.createNode(\"RotoPaint\")\n                else:\n                    c = nuke.createNode(\"SplineWarp3\")\n\n                c\[\"selected\"].setValue(False)\n\n                curve = c\['curves']\n                root = curve.rootLayer\n                newLayer = rp.Layer(curve)\n                name = \"tracked layer\"\n                newLayer.name = name\n                root.append(newLayer)\n                curve.changed()\n                layer = curve.toElement(name)\n                transform = layer.getTransform()\n            \n                for i in range(ff, lf+1):\n                    matrixAtFrame = matrixList\[i-ff]\n                    for j in range(16):\n                        extraMatrixKnob = transform.getExtraMatrixAnimCurve(0,j)\n                        extraMatrixKnob.addKey(i,matrixAtFrame\[j])\n\n            else:\n\n                c = nuke.createNode(\"GridWarp3\")\n                c\[\"source_grid_transform_matrix\"].setAnimated()\n\n                # Setup progress bar.\n                task = nuke.ProgressTask('Adding keyframes...')\n                progressCalc = 100.0/float(lf-ff)\n                counter = 0\n\n                for i in range(ff, lf+1):\n                    matrixAtFrame = matrixList\[i-ff]\n                    for j in range(16):\n                        c\[\"source_grid_transform_matrix\"].setValueAt(matrixAtFrame\[j], i, j,)\n\n                    if task.isCancelled(): \n                        print \"Cancelled by user.\"\n                        break\n\n                    # Update progressbar.\n                    task.setProgress(int(counter*progressCalc))\n                    task.setMessage(\"Frame \{0\}\".format(i))\n                    counter +=1\n\n                del task\n\n            c\[\"label\"].setValue(\"reference frame: \{0\}\".format(ref))\n\n        # Setup node.\n        c\[\"xpos\"].setValue(n\[\"xpos\"].value())\n        c\[\"ypos\"].setValue(n\[\"ypos\"].value()+100)\n        c\[\"selected\"].setValue(False)\n        c.setInput(0, None)\n\nsb_positionTracker()" +STARTLINE}
addUserKnob {26 divider6 l "" +STARTLINE}
}
Input {
inputs 0
name img
xpos -244
ypos 9
}
Output {
name Output1
xpos -244
ypos 189
}
Input {
inputs 0
name position
xpos -552
ypos -22
number 1
}
Shuffle {
in rgb
name position_to_rgb
xpos -552
ypos 99
}
NoOp {
name sampler
xpos -552
ypos 203
addUserKnob {20 User}
addUserKnob {18 bl_sampler l "bottom left"}
bl_sampler {0 0 0}
addUserKnob {6 bl_sampler_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
addUserKnob {18 br_sampler l "bottom right"}
br_sampler {0 0 0}
addUserKnob {6 br_sampler_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
addUserKnob {18 ur_sampler l "upper right"}
ur_sampler {0 0 0}
addUserKnob {6 ur_sampler_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
addUserKnob {18 ul_sampler l "upper left"}
ul_sampler {0 0 0}
addUserKnob {6 ul_sampler_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
}
Input {
inputs 0
name camera
label "\[value number]"
xpos -41
ypos 21
number 2
}
end_group
